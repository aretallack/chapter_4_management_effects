---
title: "Extract annual minimum and maximum values"
format: html
---

For each pixel, extract the minimum of each of the cover values within a 
calendar year. Analysis can then be made on just the min or max, and the 
preciding 3 or 12 months of precipitation from this time.


```{r}
#| label: setup
pacman::p_load(arrow, tidyverse, data.table, dtplyr)
```

# select min and max cover rows

For each cell and year, get the minimum and maximum of each cover type

```{r}
d1 <- arrow::read_parquet("./outputs/tables/bonbon.parquet")

# Use dtplyr to work out the tricky data.table query
# library(dtplyr)
# d1 %>%
#   lazy_dt() %>%
#   group_by(x,y,year) %>%
#   filter(pv == min(pv)) %>%
#   show_query()

# d1 %>%
#   lazy_dt() %>%
#   group_by(x,y,year) %>%
#   filter(pv == quantile(pv, c(0.05))) %>%
#   show_query()

d2 <- rbindlist(list(
  d1[is.na(pv) == F][d1[, .I[pv == quantile(pv, c(0.05))], by = .(x, y, year)]$V1] %>% 
  rename(pv_05 = pv), 
    d1[is.na(pv) == F][d1[, .I[pv == quantile(pv, c(0.95))], by = .(x, y, year)]$V1] %>% 
  rename(pv_95 = pv),  
  d1[is.na(pv) == F][d1[, .I[pv == min(pv)], by = .(x, y, year)]$V1] %>% 
  rename(pv_min = pv), 
    d1[is.na(pv) == F][d1[, .I[pv == max(pv)], by = .(x, y, year)]$V1] %>% 
  rename(pv_max = pv),
  
  d1[is.na(npv) == F][d1[, .I[npv == quantile(npv, c(0.05))], by = .(x, y, year)]$V1] %>% 
    rename(npv_05 = npv), 
  d1[is.na(npv) == F][d1[, .I[npv == quantile(npv, c(0.95))], by = .(x, y, year)]$V1] %>% 
    rename(npv_95 = npv),
  d1[is.na(npv) == F][d1[, .I[npv == min(npv)], by = .(x, y, year)]$V1] %>% 
    rename(npv_min = npv), 
  d1[is.na(npv) == F][d1[, .I[npv == max(npv)], by = .(x, y, year)]$V1] %>% 
    rename(npv_max = npv),
  
  d1[is.na(bare) == F][d1[, .I[bare == quantile(bare, c(0.05))], by = .(x, y, year)]$V1] %>% 
    rename(bare_05 = bare), 
  d1[is.na(bare) == F][d1[, .I[bare == quantile(bare, c(0.95))], by = .(x, y, year)]$V1] %>% 
    rename(bare_95 = bare),
  d1[is.na(bare) == F][d1[, .I[bare == min(bare)], by = .(x, y, year)]$V1] %>% 
    rename(bare_min = bare), 
  d1[is.na(bare) == F][d1[, .I[bare == max(bare)], by = .(x, y, year)]$V1] %>% 
    rename(bare_max = bare)
  ), fill = T)

```

# save file

```{r}
write_parquet(d2, "./outputs/tables/bonbon_minmax.parquet")
```


```{r}
# visual checks 
d2[,.(val_min = mean(pv_min,na.rm=T), 
      val_max = mean(pv_max,na.rm=T)), by=year] %>% 
  pivot_longer(-year) %>% 
  ggplot(aes(year,value,color=name))+
  geom_line()

d2[,.(val_min = mean(npv_min,na.rm=T), 
      val_max = mean(npv_max,na.rm=T)), by=year] %>% 
  pivot_longer(-year) %>% 
  ggplot(aes(year,value,color=name))+
  geom_line()

## THERE IS SOMETHING WEIRD GOING ON IN 2023
## because 2023 only has one month of data? unclear
d2[,.(val_min = mean(bare_min,na.rm=T), 
      val_max = mean(bare_max,na.rm=T)), by=year] %>% 
  pivot_longer(-year) %>% 
  ggplot(aes(year,value,color=name))+
  geom_line()+geom_point()


d2[year==2023]$bare_min %>% summary()
d2[year==2023]$bare_max %>% summary()

min(d1[year==2023][is.na(bare)==F]$bare,na.rm=T)
max(d1[year==2023][is.na(bare)==F]$bare,na.rm=T)
min(d1[year==2023]$bare,na.rm=T)
max(d1[year==2023]$bare,na.rm=T)
d1[year==2023]$bare %>% summary
d2[year==2023]$bare_min %>% summary()
d2[year==2023]$bare_max %>% summary()


```

